# Architecture (Frontend-first, Feature + Clean Layers)

This repo is migrating to a **feature-first** structure with Clean Architecture dependency rules, to support long-term goals like **plugin-driven customization** (themes, voice, etc.).

## Folder conventions

### `src/features/<feature>/`

Each feature is a vertical slice with the following fixed folders:

- `domain/` – business core (no framework dependencies)
  - `usecases/` – application use-cases (orchestrate domain rules via ports)
- `data/` – adapters that implement `domain` ports (Tauri, storage, network, etc.)
- `presentation/` – Vue UI (pages/components/view-models)
- `di/` – feature composition root (wire usecases + adapters)
- `mock/` – fake/in-memory adapters for demos/tests
- `test/` – feature tests (prefer `domain/usecases` first)

### `src/shared/`

Cross-feature utilities and infrastructure helpers. It must not contain business rules.

### `src/app/`

Application bootstrap (router/app-level DI/global styles).

## Dependency rules (must hold)

Within a feature:

- `domain` must not import from Vue, Tauri, browser APIs, or any `data/presentation/di`.
- `usecases` must only depend on `domain` (entities/types/errors) + `domain/ports`.
- `data` depends on `domain` (implements ports).
- `presentation` depends on `domain` (calls usecases via DI) and must not call raw Tauri directly.
- `di` wires `presentation` to `usecases` + `data`.

Across features:

- A feature must not import another feature’s `data/presentation/di`.
- Cross-feature collaboration should happen via `shared/` or via well-defined ports/events.

## Tauri boundary

All Tauri command/event names and invocation helpers should be centralized under:

- `src/shared/tauri/`

This keeps the platform boundary explicit and reduces ad-hoc `invoke()`/`listen()` usage scattered across the UI.

## Plugins (later stage)

Plugins will be treated as external components with:

- versioned **contracts** (TypeScript-first)
- explicit **capabilities/permissions**
- explicit **extension points** (theme provider, voice provider, etc.)

Plugins should not directly mutate application internals; they register providers through host-controlled APIs.

